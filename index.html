<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Lunar Lander Game</title>
        <style>
            body {
                margin: 0;
                padding: 0;
                background: #000;
                color: #fff;
                font-family: "Courier New", monospace;
                overflow: hidden;
                display: flex;
                justify-content: center;
                align-items: center;
                height: 100vh;
            }

            #gameContainer {
                position: relative;
                border: 2px solid #333;
            }

            #gameCanvas {
                background: linear-gradient(
                    to bottom,
                    #001122 0%,
                    #000011 50%,
                    #000000 100%
                );
                display: block;
            }

            #hud {
                position: absolute;
                top: 10px;
                left: 10px;
                font-size: 16px;
                line-height: 1.5;
                text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            }

            #message {
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                font-size: 24px;
                font-weight: bold;
                text-align: center;
                background: rgba(0, 0, 0, 0.8);
                padding: 20px;
                border-radius: 10px;
                border: 2px solid #fff;
                display: none;
            }

            #controls {
                position: absolute;
                bottom: 10px;
                left: 10px;
                font-size: 12px;
                line-height: 1.3;
                text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            }

            .win {
                color: #00ff00;
                border-color: #00ff00;
            }

            .lose {
                color: #ff0000;
                border-color: #ff0000;
            }
        </style>
    </head>
    <body>
        <div id="gameContainer">
            <canvas id="gameCanvas" width="800" height="600"></canvas>

            <div id="hud">
                <div>Level: <span id="level">1</span></div>
                <div>Waypoints: <span id="waypoints">0</span>/<span id="waypointsTotal">0</span></div>
                <div>Fuel: <span id="fuel">100</span>%</div>
                <div>Velocity: <span id="velocity">0.0</span> m/s</div>
                <div>Altitude: <span id="altitude">0</span> m</div>
                <div>Angle: <span id="angle">0</span>°</div>
            </div>

            <div id="message">
                <div id="messageText"></div>
                <div style="margin-top: 10px; font-size: 16px">
                    Press SPACE to restart / continue
                </div>
            </div>

            <div id="controls">
                <div>↑ - Thrust</div>
                <div>← → - Rotate</div>
                <div>SPACE - Restart (when game over)</div>
            </div>
        </div>

        <script>
            // Game constants
            const CANVAS_WIDTH = 800;
            const CANVAS_HEIGHT = 600;
            const SAFE_LANDING_VELOCITY = 2;
            const SAFE_LANDING_ANGLE = 15;

            // Difficulty levels (progressively harder)
            const levels = [
                {
                    name: "Easy",
                    // made slightly tougher than before
                    gravity: 0.01,
                    thrust: 0.055,
                    rotation: 2,
                    fuel: 120,
                    fuelConsumption: 0.2,
                    padWidth: 130,
                    terrainVariance: 140,
                    requiredWaypoints: 2,
                    obstacles: 2,
                    meteorSpeedMultiplier: 1.0,
                },
                {
                    name: "Normal",
                    gravity: 0.013,
                    thrust: 0.045,
                    rotation: 2.3,
                    fuel: 90,
                    fuelConsumption: 0.28,
                    padWidth: 100,
                    terrainVariance: 180,
                    requiredWaypoints: 2,
                    obstacles: 3,
                    meteorSpeedMultiplier: 1.3,
                },
                {
                    name: "Hard",
                    gravity: 0.017,
                    thrust: 0.04,
                    rotation: 2.8,
                    fuel: 60,
                    fuelConsumption: 0.36,
                    padWidth: 70,
                    terrainVariance: 230,
                    requiredWaypoints: 2,
                    obstacles: 5,
                    meteorSpeedMultiplier: 1.7,
                },
            ];

            let currentLevel = 0;
            let activeConfig = levels[currentLevel];

            // Get canvas and context
            const canvas = document.getElementById("gameCanvas");
            const ctx = canvas.getContext("2d");

            // Game state
            let gameState = "playing"; // 'playing', 'won', 'crashed'

            // Player lander object
            const lander = {
                x: CANVAS_WIDTH / 2,
                y: 100,
                vx: 0,
                vy: 0,
                angle: 0,
                fuel: 100,
                size: 15,
                thrustActive: false,
            };

            // Terrain points for landing surface
            const terrain = [];
            const waypoints = [];
            let collectedWaypoints = 0;
            const obstacles = [];
            let landingPadX = CANVAS_WIDTH / 2 - 60;
            let landingPadWidth = activeConfig.padWidth;
            const landingPadY = CANVAS_HEIGHT - 50;

            // Input handling
            const keys = {};

            // Initialize terrain using activeConfig.terrainVariance and pad position/width
            function initTerrain() {
                terrain.length = 0;

                // ensure landing pad width matches config
                landingPadWidth = activeConfig.padWidth;

                // Randomize landing pad X so levels feel different
                landingPadX = Math.floor(
                    100 + Math.random() * (CANVAS_WIDTH - 200 - landingPadWidth),
                );

                // Create mountainous terrain with a flat landing pad
                for (let x = 0; x <= CANVAS_WIDTH; x += 20) {
                    let height;

                    if (x >= landingPadX && x <= landingPadX + landingPadWidth) {
                        // Flat landing pad
                        height = landingPadY;
                    } else {
                        // Random mountainous terrain based on level variance
                        height =
                            CANVAS_HEIGHT - 20 - Math.random() * activeConfig.terrainVariance;
                    }

                    terrain.push({ x: x, y: height });
                }
                // create waypoints after terrain is ready
                initWaypoints();
                initObstacles();
            }

            // Initialize obstacles for the level
            function initObstacles() {
                obstacles.length = 0;
                const count = activeConfig.obstacles || 0;
                for (let i = 0; i < count; i++) {
                    // spawn meteors off the top of the screen with downward velocity
                    const x = Math.random() * CANVAS_WIDTH;
                    const y = -20 - Math.random() * 400;
                    const r = 8 + Math.random() * 18;
                    const vx = (Math.random() * 2 - 1) * 1.5 * (activeConfig.meteorSpeedMultiplier || 1);
                    const vy = (2 + Math.random() * 3) * (activeConfig.meteorSpeedMultiplier || 1); // downward speed
                    const spin = (Math.random() * 2 - 1) * 0.08;
                    obstacles.push({ x, y, r, vx, vy, spin });
                }
            }

            // Helper: get interpolated terrain height at x
            function getTerrainHeightAt(x) {
                // clamp
                if (x <= 0) return terrain[0].y;
                if (x >= CANVAS_WIDTH) return terrain[terrain.length - 1].y;

                for (let i = 0; i < terrain.length - 1; i++) {
                    const p1 = terrain[i];
                    const p2 = terrain[i + 1];
                    if (x >= p1.x && x <= p2.x) {
                        const ratio = (x - p1.x) / (p2.x - p1.x);
                        return p1.y + (p2.y - p1.y) * ratio;
                    }
                }
                return CANVAS_HEIGHT;
            }

            // Initialize waypoints based on activeConfig.requiredWaypoints
            function initWaypoints() {
                waypoints.length = 0;
                collectedWaypoints = 0;

                const total = activeConfig.requiredWaypoints || 0;
                for (let i = 0; i < total; i++) {
                    // choose an X not too close to edges
                    const x = 50 + Math.random() * (CANVAS_WIDTH - 100);
                    const terrainH = getTerrainHeightAt(x);
                    // place the waypoint above terrain, at variable height
                    const y = Math.max(80, terrainH - (100 + Math.random() * 120));
                    const r = 20;
                    waypoints.push({ x, y, r, collected: false });
                }
                document.getElementById("waypoints").textContent = collectedWaypoints;
                document.getElementById("waypointsTotal").textContent = waypoints.length;
            }

            // Reset game for the current activeConfig (keeps currentLevel)
            function resetGame(reposition = true) {
                // apply active config
                lander.x = reposition ? CANVAS_WIDTH / 2 : lander.x;
                lander.y = 100;
                lander.vx = 0;
                lander.vy = 0;
                lander.angle = 0;
                lander.fuel = activeConfig.fuel;
                lander.thrustActive = false;
                landingPadWidth = activeConfig.padWidth;
                gameState = "playing";

                document.getElementById("message").style.display = "none";
                document.getElementById("level").textContent = currentLevel + 1;
                initTerrain();
                // ensure waypoints HUD updated
                document.getElementById("waypoints").textContent = collectedWaypoints;
                document.getElementById("waypointsTotal").textContent = waypoints.length;
            }

            // Update game physics
            function update() {
                if (gameState !== "playing") return;

                // Handle input
                if (keys["ArrowLeft"]) {
                    lander.angle -= activeConfig.rotation;
                }
                if (keys["ArrowRight"]) {
                    lander.angle += activeConfig.rotation;
                }

                // Thrust
                lander.thrustActive = false;
                if (keys["ArrowUp"] && lander.fuel > 0) {
                    lander.thrustActive = true;
                    const angleRad = ((lander.angle - 90) * Math.PI) / 180;
                    lander.vx += Math.cos(angleRad) * activeConfig.thrust;
                    lander.vy += Math.sin(angleRad) * activeConfig.thrust;
                    lander.fuel -= activeConfig.fuelConsumption;
                    if (lander.fuel < 0) lander.fuel = 0;
                }

                // Apply gravity (from level config)
                lander.vy += activeConfig.gravity;

                // Update position
                lander.x += lander.vx;
                lander.y += lander.vy;

                // Keep lander on screen horizontally
                if (lander.x < 0) lander.x = CANVAS_WIDTH;
                if (lander.x > CANVAS_WIDTH) lander.x = 0;

                // Check for ground collision
                checkCollision();

                // Check for waypoint collection
                checkWaypoints();

                // Check for obstacle collisions
                checkObstacleCollision();
                // Move meteors
                updateObstacles();

                // Update HUD
                updateHUD();
            }

            // Check collision with terrain
            function checkCollision() {
                // Simple collision detection - check if lander is below terrain at its position
                for (let i = 0; i < terrain.length - 1; i++) {
                    const point1 = terrain[i];
                    const point2 = terrain[i + 1];

                    if (lander.x >= point1.x && lander.x <= point2.x) {
                        // Interpolate terrain height at lander position
                        const ratio =
                            (lander.x - point1.x) / (point2.x - point1.x);
                        const terrainHeight =
                            point1.y + (point2.y - point1.y) * ratio;

                        if (lander.y + lander.size >= terrainHeight) {
                            // Collision detected
                            const velocity = Math.sqrt(
                                lander.vx * lander.vx + lander.vy * lander.vy,
                            );
                            const angleDiff = Math.abs(lander.angle % 360);
                            const normalizedAngle =
                                angleDiff > 180 ? 360 - angleDiff : angleDiff;

                            // Check if it's a safe landing
                            if (
                                velocity <= SAFE_LANDING_VELOCITY &&
                                normalizedAngle <= SAFE_LANDING_ANGLE &&
                                lander.x >= landingPadX &&
                                lander.x <= landingPadX + landingPadWidth
                            ) {
                                // Require all waypoints collected to win
                                if (collectedWaypoints >= waypoints.length) {
                                    gameState = "won";
                                    lander.vx = 0;
                                    lander.vy = 0;
                                    lander.y = terrainHeight - lander.size;
                                    showMessage("MISSION is SUCCESSFUL! Press SPACE to continue to next level.", "win");
                                } else {
                                    gameState = "crashed";
                                    lander.vx = 0;
                                    lander.vy = 0;
                                    lander.y = terrainHeight - lander.size;
                                    showMessage("You missed waypoints! Press SPACE to retry.", "lose");
                                }
                            } else {
                                // Crash!
                                gameState = "crashed";
                                lander.vx = 0;
                                lander.vy = 0;
                                lander.y = terrainHeight - lander.size;
                                showMessage("LANDER CRASHED! Press SPACE to retry level.", "lose");
                            }
                            break;
                        }
                    }
                }

                // Check if lander is too high (off screen)
                if (lander.y < -50) {
                    lander.y = -50;
                    lander.vy = 0;
                }
            }

            // Show win/lose message
            function showMessage(text, type) {
                const messageEl = document.getElementById("message");
                const messageTextEl = document.getElementById("messageText");

                messageTextEl.textContent = text;
                messageEl.className = type;
                messageEl.style.display = "block";
            }

            // Update HUD display
            function updateHUD() {
                document.getElementById("fuel").textContent = Math.ceil(
                    lander.fuel,
                );

                const velocity = Math.sqrt(
                    lander.vx * lander.vx + lander.vy * lander.vy,
                );
                document.getElementById("velocity").textContent =
                    velocity.toFixed(1);

                const altitude = Math.max(
                    0,
                    Math.round((CANVAS_HEIGHT - lander.y - 50) / 5),
                );
                document.getElementById("altitude").textContent = altitude;

                // normalize angle to -180..180 for display
                let displayAngle = ((lander.angle % 360) + 360) % 360;
                if (displayAngle > 180) displayAngle -= 360;
                document.getElementById("angle").textContent = Math.round(displayAngle);

                // clamp and display fuel
                document.getElementById("fuel").textContent = Math.max(0, Math.ceil(lander.fuel));
                // waypoints
                document.getElementById("waypoints").textContent = collectedWaypoints;
                document.getElementById("waypointsTotal").textContent = waypoints.length;
            }

            // Check if lander passes through waypoints
            function checkWaypoints() {
                if (!waypoints || waypoints.length === 0) return;
                for (let i = 0; i < waypoints.length; i++) {
                    const wp = waypoints[i];
                    if (wp.collected) continue;
                    const dx = lander.x - wp.x;
                    const dy = lander.y - wp.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist <= wp.r) {
                        wp.collected = true;
                        collectedWaypoints += 1;
                        // Reward: restore 30% of level-starting fuel, clamp to level max
                        const fuelGain = activeConfig.fuel * 0.3;
                        lander.fuel = Math.min(activeConfig.fuel, lander.fuel + fuelGain);
                    }
                }
            }

            // Check collision with obstacles
            function checkObstacleCollision() {
                for (let i = 0; i < obstacles.length; i++) {
                    const ob = obstacles[i];
                    const dx = lander.x - ob.x;
                    const dy = lander.y - ob.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist <= ob.r + lander.size * 0.6) {
                        // immediate crash
                        gameState = "crashed";
                        lander.vx = 0;
                        lander.vy = 0;
                        showMessage("You hit an obstacle! Press SPACE to retry.", "lose");
                        return;
                    }
                }
            }

            // Move meteors and respawn them if they exit the play area
            function updateObstacles() {
                for (let i = 0; i < obstacles.length; i++) {
                    const ob = obstacles[i];
                    ob.x += ob.vx;
                    ob.y += ob.vy;
                    // small spin can affect aesthetics if needed
                    ob.r += Math.sin((Date.now() * 0.001 + i) * (ob.spin || 0)) * 0.02;

                    // respawn if below screen or far off sides
                    if (ob.y - ob.r > CANVAS_HEIGHT + 100 || ob.x < -200 || ob.x > CANVAS_WIDTH + 200) {
                        ob.x = Math.random() * CANVAS_WIDTH;
                        ob.y = -20 - Math.random() * 300;
                        ob.vx = (Math.random() * 2 - 1) * 1.5 * (activeConfig.meteorSpeedMultiplier || 1);
                        ob.vy = (2 + Math.random() * 3) * (activeConfig.meteorSpeedMultiplier || 1);
                        ob.r = 8 + Math.random() * 18;
                    }
                }
            }

            // Draw waypoints
            function drawWaypoints() {
                for (let i = 0; i < waypoints.length; i++) {
                    const wp = waypoints[i];
                    ctx.beginPath();
                    ctx.arc(wp.x, wp.y, wp.r, 0, Math.PI * 2);
                    ctx.strokeStyle = wp.collected ? "#00ff00" : "#ffcc00";
                    ctx.lineWidth = 3;
                    ctx.stroke();

                    // inner ring
                    ctx.beginPath();
                    ctx.arc(wp.x, wp.y, wp.r * 0.6, 0, Math.PI * 2);
                    ctx.fillStyle = wp.collected ? "rgba(0,255,0,0.2)" : "rgba(255,204,0,0.08)";
                    ctx.fill();
                }
            }

            // Draw obstacles
            function drawObstacles() {
                for (let i = 0; i < obstacles.length; i++) {
                    const ob = obstacles[i];
                    // tail
                    ctx.beginPath();
                    ctx.moveTo(ob.x - ob.vx * 6, ob.y - ob.vy * 6);
                    ctx.lineTo(ob.x - ob.vx * 2, ob.y - ob.vy * 2);
                    ctx.strokeStyle = "rgba(255,150,50,0.35)";
                    ctx.lineWidth = Math.max(2, ob.r * 0.4);
                    ctx.stroke();

                    // meteor body
                    ctx.beginPath();
                    ctx.arc(ob.x, ob.y, ob.r, 0, Math.PI * 2);
                    ctx.fillStyle = "#ff9933";
                    ctx.fill();
                    ctx.strokeStyle = "#ffcc88";
                    ctx.lineWidth = 1.5;
                    ctx.stroke();
                }
            }

            // Draw everything
            function draw() {
                // Clear canvas
                ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                // Draw stars
                drawStars();

                // Draw terrain
                drawTerrain();

                // Draw waypoints (behind lander)
                drawWaypoints();

                // Draw obstacles
                drawObstacles();

                // Draw landing pad indicator
                drawLandingPad();

                // Draw lander
                drawLander();

                // Draw thrust effect
                if (lander.thrustActive && gameState === "playing") {
                    drawThrust();
                }
            }

            // Draw background stars
            function drawStars() {
                ctx.fillStyle = "#fff";
                for (let i = 0; i < 100; i++) {
                    const x = (i * 123) % CANVAS_WIDTH;
                    const y = (i * 456) % (CANVAS_HEIGHT / 2);
                    const size = ((i * 789) % 3) + 1;
                    ctx.fillRect(x, y, size, size);
                }
            }

            // Draw terrain
            function drawTerrain() {
                ctx.beginPath();
                ctx.moveTo(0, CANVAS_HEIGHT);

                for (let i = 0; i < terrain.length; i++) {
                    ctx.lineTo(terrain[i].x, terrain[i].y);
                }

                ctx.lineTo(CANVAS_WIDTH, CANVAS_HEIGHT);
                ctx.closePath();

                ctx.fillStyle = "#444";
                ctx.fill();
                ctx.strokeStyle = "#666";
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            // Draw landing pad
            function drawLandingPad() {
                ctx.fillStyle = "#00ff00";
                ctx.fillRect(landingPadX, landingPadY - 5, landingPadWidth, 5);

                // Landing pad markers
                ctx.fillStyle = "#ffff00";
                ctx.fillRect(landingPadX - 5, landingPadY - 15, 10, 10);
                ctx.fillRect(
                    landingPadX + landingPadWidth - 5,
                    landingPadY - 15,
                    10,
                    10,
                );
            }

            // Draw the lander
            function drawLander() {
                ctx.save();
                ctx.translate(lander.x, lander.y);
                ctx.rotate((lander.angle * Math.PI) / 180);

                // Lander body (triangle)
                ctx.beginPath();
                ctx.moveTo(0, -lander.size);
                ctx.lineTo(-lander.size * 0.6, lander.size * 0.5);
                ctx.lineTo(lander.size * 0.6, lander.size * 0.5);
                ctx.closePath();

                ctx.fillStyle = gameState === "crashed" ? "#ff0000" : "#00ccff";
                ctx.fill();
                ctx.strokeStyle = "#fff";
                ctx.lineWidth = 2;
                ctx.stroke();

                // Landing legs
                ctx.strokeStyle = "#ccc";
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(-lander.size * 0.4, lander.size * 0.3);
                ctx.lineTo(-lander.size * 0.8, lander.size * 0.8);
                ctx.moveTo(lander.size * 0.4, lander.size * 0.3);
                ctx.lineTo(lander.size * 0.8, lander.size * 0.8);
                ctx.stroke();

                ctx.restore();
            }

            // Draw thrust effect
            function drawThrust() {
                ctx.save();
                ctx.translate(lander.x, lander.y);
                ctx.rotate((lander.angle * Math.PI) / 180);

                // Thrust flame
                const flameLength = 20 + Math.random() * 10;
                ctx.beginPath();
                ctx.moveTo(-5, lander.size * 0.5);
                ctx.lineTo(0, lander.size * 0.5 + flameLength);
                ctx.lineTo(5, lander.size * 0.5);
                ctx.closePath();

                ctx.fillStyle = "#ff6600";
                ctx.fill();

                // Inner flame
                ctx.beginPath();
                ctx.moveTo(-3, lander.size * 0.5);
                ctx.lineTo(0, lander.size * 0.5 + flameLength * 0.7);
                ctx.lineTo(3, lander.size * 0.5);
                ctx.closePath();

                ctx.fillStyle = "#ffff00";
                ctx.fill();

                ctx.restore();
            }

            // Main game loop
            function gameLoop() {
                update();
                draw();
                requestAnimationFrame(gameLoop);
            }

            // Event listeners
            document.addEventListener("keydown", (e) => {
                keys[e.code] = true;

                // Space handling: next level on win, retry on crash
                if (e.code === "Space" && gameState !== "playing") {
                    e.preventDefault();
                    if (gameState === "won") {
                        // advance level if possible
                        if (currentLevel < levels.length - 1) {
                            currentLevel += 1;
                            activeConfig = levels[currentLevel];
                            showMessage(`Starting level ${currentLevel + 1}: ${activeConfig.name}`, "");
                        } else {
                            showMessage("All levels complete! Restarting at Level 1.", "");
                            currentLevel = 0;
                            activeConfig = levels[currentLevel];
                        }
                        resetGame();
                    } else if (gameState === "crashed") {
                        // retry same level
                        activeConfig = levels[currentLevel];
                        resetGame();
                    }
                }
            });

            document.addEventListener("keyup", (e) => {
                keys[e.code] = false;
            });

            // Prevent arrow keys from scrolling the page
            document.addEventListener("keydown", (e) => {
                if (
                    [
                        "ArrowUp",
                        "ArrowDown",
                        "ArrowLeft",
                        "ArrowRight",
                        "Space",
                    ].includes(e.code)
                ) {
                    e.preventDefault();
                }
            });

            // Initialize and start game
            initTerrain();
            resetGame();
            gameLoop();
        </script>
    </body>
</html>
