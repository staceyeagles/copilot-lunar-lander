<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Lunar Lander Game</title>
        <style>
            body {
                margin: 0;
                padding: 0;
                background: #000;
                color: #fff;
                font-family: "Courier New", monospace;
                overflow: hidden;
                display: flex;
                justify-content: center;
                align-items: center;
                height: 100vh;
            }

            #gameContainer {
                position: relative;
                border: 2px solid #333;
            }

            #gameCanvas {
                background: linear-gradient(
                    to bottom,
                    #001122 0%,
                    #000011 50%,
                    #000000 100%
                );
                display: block;
            }

            #hud {
                position: absolute;
                top: 10px;
                left: 10px;
                font-size: 16px;
                line-height: 1.5;
                text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            }

            #message {
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                font-size: 24px;
                font-weight: bold;
                text-align: center;
                background: rgba(0, 0, 0, 0.8);
                padding: 20px;
                border-radius: 10px;
                border: 2px solid #fff;
                display: none;
            }

            #controls {
                position: absolute;
                bottom: 10px;
                left: 10px;
                font-size: 12px;
                line-height: 1.3;
                text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            }

            /* immunity HUD in the top-right corner */
            #immunity {
                position: absolute;
                top: 10px;
                right: 10px;
                font-size: 16px;
                background: rgba(0,0,0,0.6);
                padding: 6px 10px;
                border-radius: 6px;
                border: 1px solid #44ff88;
                color: #aaffcc;
                display: none;
                text-align: center;
                min-width: 80px;
            }

            /* transient toast notification */
            #toast {
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0,0,0,0.8);
                color: #fff;
                padding: 8px 12px;
                border-radius: 8px;
                border: 1px solid #888;
                display: none;
                font-size: 18px;
                pointer-events: none;
            }

            /* initial instructions overlay */
            #instructions {
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0,0,0,0.9);
                color: #fff;
                padding: 18px 24px;
                border-radius: 10px;
                border: 2px solid #666;
                max-width: 520px;
                text-align: left;
                font-size: 14px;
                line-height: 1.4;
            }

            .win {
                color: #00ff00;
                border-color: #00ff00;
            }

            .lose {
                color: #ff0000;
                border-color: #ff0000;
            }
        </style>
    </head>
    <body>
        <div id="gameContainer">
            <canvas id="gameCanvas" width="800" height="600"></canvas>

            <div id="hud">
                <div>Level: <span id="level">1</span></div>
                <div>Waypoints: <span id="waypoints">0</span>/<span id="waypointsTotal">0</span></div>
                <div>Fuel: <span id="fuel">100</span>%</div>
                <div>Ammo: <span id="ammo">0</span></div>
                <div>Velocity: <span id="velocity">0.0</span> m/s</div>
                <div>Altitude: <span id="altitude">0</span> m</div>
                <div>Angle: <span id="angle">0</span>°</div>
            </div>

            <div id="message">
                <div id="messageText"></div>
                <div style="margin-top: 10px; font-size: 16px">
                    Press SPACE to restart / continue
                </div>
            </div>

            <div id="controls">
                <div>↑ - Thrust</div>
                <div>← → - Rotate</div>
                <div>SPACE - Shoot (during play) / Restart (when game over)</div>
            </div>
            <div id="immunity">Immunity: <span id="immunityTimer">5</span>s</div>
            <div id="toast"></div>
            <div id="instructions">
                <strong>How to play</strong>
                <ul style="margin-top:8px">
                    <li>Arrow Up: Thrust</li>
                    <li>Left / Right: Rotate</li>
                    <li>Space: Shoot (during play). When game over, Space restarts/advances.</li>
                    <li>Collect waypoints to restore fuel and gain 5s asteroid immunity.</li>
                    <li>Land on the green pad with low speed and near 0° to win.</li>
                </ul>
                <div style="margin-top:10px; text-align:center">Press <strong>SPACE</strong> to start</div>
            </div>
        </div>

        <script>
            // Game constants
            const CANVAS_WIDTH = 800;
            const CANVAS_HEIGHT = 600;
            const SAFE_LANDING_VELOCITY = 2;
            const SAFE_LANDING_ANGLE = 15;

            // Difficulty levels (progressively harder)
            const levels = [
                {
                    name: "Easy",
                    // made slightly tougher than before
                    gravity: 0.01,
                    thrust: 0.055,
                    rotation: 2,
                    fuel: 120,
                    fuelConsumption: 0.14,
                    padWidth: 130,
                    terrainVariance: 140,
                    requiredWaypoints: 2,
                    obstacles: 2,
                    meteorSpeedMultiplier: 1.0,
                },
                {
                    name: "Normal",
                    gravity: 0.013,
                    thrust: 0.045,
                    rotation: 2.3,
                    fuel: 90,
                    fuelConsumption: 0.20,
                    padWidth: 100,
                    terrainVariance: 180,
                    requiredWaypoints: 2,
                    obstacles: 3,
                    meteorSpeedMultiplier: 1.3,
                },
                {
                    name: "Hard",
                    gravity: 0.017,
                    thrust: 0.04,
                    rotation: 2.8,
                    fuel: 60,
                    fuelConsumption: 0.25,
                    padWidth: 70,
                    terrainVariance: 230,
                    requiredWaypoints: 2,
                    obstacles: 5,
                    meteorSpeedMultiplier: 1.7,
                },
            ];

            let currentLevel = 0;
            let activeConfig = levels[currentLevel];

            // Get canvas and context
            const canvas = document.getElementById("gameCanvas");
            const ctx = canvas.getContext("2d");

            // Game state
            let gameState = "playing"; // 'playing', 'won', 'crashed'

            // Player lander object
            const lander = {
                x: CANVAS_WIDTH / 2,
                y: 100,
                vx: 0,
                vy: 0,
                angle: 0,
                fuel: 100,
                size: 15,
                thrustActive: false,
            };

            // Terrain points for landing surface
            const terrain = [];
            const waypoints = [];
            let collectedWaypoints = 0;
            const obstacles = [];
            // Bullets fired by the lander
            const bullets = [];
            const BULLET_SPEED = 8;
            const BULLET_RADIUS = 3;
            let lastShotTime = 0;
            const SHOT_COOLDOWN = 150; // ms between shots
            // Ammo tracking
            let ammo = 10; // default, overwritten by level config
            // store reason for last loss to generate tips
            let lastLossReason = null; // 'crash', 'hit_obstacle', 'miss_waypoints'
            // Immunity state (gained from waypoints)
            let immunityActive = false;
            let immunityEndsAt = 0;
            let landingPadX = CANVAS_WIDTH / 2 - 60;
            let landingPadWidth = activeConfig.padWidth;
            const landingPadY = CANVAS_HEIGHT - 50;

            // Input handling
            const keys = {};

            // startup/obstacle timing
            let firstStart = true;
            let obstaclesStarted = false;

            // Initialize terrain using activeConfig.terrainVariance and pad position/width
            function initTerrain() {
                terrain.length = 0;

                // ensure landing pad width matches config
                landingPadWidth = activeConfig.padWidth;

                // Randomize landing pad X so levels feel different
                landingPadX = Math.floor(
                    100 + Math.random() * (CANVAS_WIDTH - 200 - landingPadWidth),
                );

                // Create mountainous terrain with a flat landing pad
                for (let x = 0; x <= CANVAS_WIDTH; x += 20) {
                    let height;

                    if (x >= landingPadX && x <= landingPadX + landingPadWidth) {
                        // Flat landing pad
                        height = landingPadY;
                    } else {
                        // Random mountainous terrain based on level variance
                        height =
                            CANVAS_HEIGHT - 20 - Math.random() * activeConfig.terrainVariance;
                    }

                    terrain.push({ x: x, y: height });
                }
                // create waypoints after terrain is ready
                initWaypoints();
            }

            // Initialize obstacles for the level
            function initObstacles() {
                obstacles.length = 0;
                const count = activeConfig.obstacles || 0;
                for (let i = 0; i < count; i++) {
                    // spawn meteors off the top of the screen with downward velocity
                    const x = Math.random() * CANVAS_WIDTH;
                    const y = -20 - Math.random() * 400;
                    const r = 8 + Math.random() * 18;
                    const vx = (Math.random() * 2 - 1) * 1.5 * (activeConfig.meteorSpeedMultiplier || 1);
                    const vy = (2 + Math.random() * 3) * (activeConfig.meteorSpeedMultiplier || 1); // downward speed
                    const spin = (Math.random() * 2 - 1) * 0.08;
                    obstacles.push({ x, y, r, vx, vy, spin });
                }
            }

            // Helper: get interpolated terrain height at x
            function getTerrainHeightAt(x) {
                // clamp
                if (x <= 0) return terrain[0].y;
                if (x >= CANVAS_WIDTH) return terrain[terrain.length - 1].y;

                for (let i = 0; i < terrain.length - 1; i++) {
                    const p1 = terrain[i];
                    const p2 = terrain[i + 1];
                    if (x >= p1.x && x <= p2.x) {
                        const ratio = (x - p1.x) / (p2.x - p1.x);
                        return p1.y + (p2.y - p1.y) * ratio;
                    }
                }
                return CANVAS_HEIGHT;
            }

            // Initialize waypoints based on activeConfig.requiredWaypoints
            function initWaypoints() {
                waypoints.length = 0;
                collectedWaypoints = 0;
                // Make each advanced level add one more waypoint than the previous.
                // activeConfig.requiredWaypoints is the base per-level value; add currentLevel (0-based)
                const base = activeConfig.requiredWaypoints || 0;
                const total = base + currentLevel;
                for (let i = 0; i < total; i++) {
                    // choose an X not too close to edges
                    const x = 50 + Math.random() * (CANVAS_WIDTH - 100);
                    const terrainH = getTerrainHeightAt(x);
                    // place the waypoint above terrain, at variable height
                    const y = Math.max(80, terrainH - (100 + Math.random() * 120));
                    const r = 20;
                    waypoints.push({ x, y, r, collected: false });
                }
                document.getElementById("waypoints").textContent = collectedWaypoints;
                document.getElementById("waypointsTotal").textContent = waypoints.length;
            }

            // Reset game for the current activeConfig (keeps currentLevel)
            function resetGame(reposition = true) {
                // apply active config
                lander.x = reposition ? CANVAS_WIDTH / 2 : lander.x;
                lander.y = 100;
                lander.vx = 0;
                lander.vy = 0;
                lander.angle = 0;
                lander.fuel = activeConfig.fuel;
                lander.thrustActive = false;
                landingPadWidth = activeConfig.padWidth;
                gameState = "playing";

                document.getElementById("message").style.display = "none";
                document.getElementById("level").textContent = currentLevel + 1;
                // set level ammo (if not specified, keep default)
                ammo = activeConfig.ammo || 10;
                initTerrain();
                // start obstacles immediately if we've already passed the initial instructions
                if (!firstStart) {
                    initObstacles();
                    obstaclesStarted = true;
                }
                // ensure waypoints HUD updated
                document.getElementById("waypoints").textContent = collectedWaypoints;
                document.getElementById("waypointsTotal").textContent = waypoints.length;
                // reset last loss reason
                lastLossReason = null;
                document.getElementById("ammo").textContent = ammo;
            }

            // Update game physics
            function update() {
                if (gameState !== "playing") return;

                // Handle input
                if (keys["ArrowLeft"]) {
                    lander.angle -= activeConfig.rotation;
                }
                if (keys["ArrowRight"]) {
                    lander.angle += activeConfig.rotation;
                }

                // Thrust
                lander.thrustActive = false;
                if (keys["ArrowUp"] && lander.fuel > 0) {
                    lander.thrustActive = true;
                    const angleRad = ((lander.angle - 90) * Math.PI) / 180;
                    lander.vx += Math.cos(angleRad) * activeConfig.thrust;
                    lander.vy += Math.sin(angleRad) * activeConfig.thrust;
                    lander.fuel -= activeConfig.fuelConsumption;
                    if (lander.fuel < 0) lander.fuel = 0;
                }

                // Apply gravity (from level config)
                lander.vy += activeConfig.gravity;

                // Update position
                lander.x += lander.vx;
                lander.y += lander.vy;

                // Keep lander on screen horizontally
                if (lander.x < 0) lander.x = CANVAS_WIDTH;
                if (lander.x > CANVAS_WIDTH) lander.x = 0;

                // Check for ground collision
                checkCollision();

                // Check for waypoint collection
                checkWaypoints();

                // Check for obstacle collisions
                checkObstacleCollision();
                // Move meteors
                updateObstacles();

                // disable immunity if time expired
                if (immunityActive && Date.now() > immunityEndsAt) {
                    immunityActive = false;
                }

                // Move bullets and handle bullet-obstacle collisions
                updateBullets();
                checkBulletCollisions();

                // Update shrapnel visuals
                updateShrapnel();

                // Update HUD
                updateHUD();
            }

            // Check collision with terrain
            function checkCollision() {
                // Simple collision detection - check if lander is below terrain at its position
                for (let i = 0; i < terrain.length - 1; i++) {
                    const point1 = terrain[i];
                    const point2 = terrain[i + 1];

                    if (lander.x >= point1.x && lander.x <= point2.x) {
                        // Interpolate terrain height at lander position
                        const ratio =
                            (lander.x - point1.x) / (point2.x - point1.x);
                        const terrainHeight =
                            point1.y + (point2.y - point1.y) * ratio;

                        if (lander.y + lander.size >= terrainHeight) {
                            // Collision detected
                            const velocity = Math.sqrt(
                                lander.vx * lander.vx + lander.vy * lander.vy,
                            );
                            const angleDiff = Math.abs(lander.angle % 360);
                            const normalizedAngle =
                                angleDiff > 180 ? 360 - angleDiff : angleDiff;

                            // Check if it's a safe landing
                            if (
                                velocity <= SAFE_LANDING_VELOCITY &&
                                normalizedAngle <= SAFE_LANDING_ANGLE &&
                                lander.x >= landingPadX &&
                                lander.x <= landingPadX + landingPadWidth
                            ) {
                                // Require all waypoints collected to win
                                if (collectedWaypoints >= waypoints.length) {
                                    gameState = "won";
                                    lander.vx = 0;
                                    lander.vy = 0;
                                    lander.y = terrainHeight - lander.size;
                                    // compute the numeric next level (wrap to 1 if we're at the last configured level)
                                    const nextLevelNumber = currentLevel < levels.length - 1 ? currentLevel + 2 : 1;
                                    showMessage(`MISSION is SUCCESSFUL! Advancing to level: ${nextLevelNumber}. Press SPACE to continue.`, "win");
                                } else {
                                    gameState = "crashed";
                                    lander.vx = 0;
                                    lander.vy = 0;
                                    lander.y = terrainHeight - lander.size;
                                    lastLossReason = 'miss_waypoints';
                                    showMessage("You missed waypoints! Press SPACE to retry.", "lose");
                                }
                            } else {
                                // Crash!
                                gameState = "crashed";
                                lander.vx = 0;
                                lander.vy = 0;
                                lander.y = terrainHeight - lander.size;
                                lastLossReason = 'crash';
                                showMessage("LANDER CRASHED! Press SPACE to retry level.", "lose");
                            }
                            break;
                        }
                    }
                }

                // Check if lander is too high (off screen)
                if (lander.y < -50) {
                    lander.y = -50;
                    lander.vy = 0;
                }
            }

            // Show win/lose message
            function showMessage(text, type) {
                const messageEl = document.getElementById("message");
                const messageTextEl = document.getElementById("messageText");
                // If it's a lose message, append a contextual tip when available
                if (type === "lose" && lastLossReason) {
                    const tip = getTipForLoss(lastLossReason);
                    if (tip) text += "\n\nTip: " + tip;
                }

                messageTextEl.textContent = text;
                messageEl.className = type;
                messageEl.style.display = "block";
            }

            // Update HUD display
            function updateHUD() {
                document.getElementById("fuel").textContent = Math.ceil(
                    lander.fuel,
                );

                const velocity = Math.sqrt(
                    lander.vx * lander.vx + lander.vy * lander.vy,
                );
                document.getElementById("velocity").textContent =
                    velocity.toFixed(1);

                const altitude = Math.max(
                    0,
                    Math.round((CANVAS_HEIGHT - lander.y - 50) / 5),
                );
                document.getElementById("altitude").textContent = altitude;

                // normalize angle to -180..180 for display
                let displayAngle = ((lander.angle % 360) + 360) % 360;
                if (displayAngle > 180) displayAngle -= 360;
                document.getElementById("angle").textContent = Math.round(displayAngle);

                // clamp and display fuel
                document.getElementById("fuel").textContent = Math.max(0, Math.ceil(lander.fuel));
                // waypoints
                document.getElementById("waypoints").textContent = collectedWaypoints;
                document.getElementById("waypointsTotal").textContent = waypoints.length;
                // ammo
                if (document.getElementById("ammo")) document.getElementById("ammo").textContent = ammo;
                // immunity display
                const immEl = document.getElementById("immunity");
                if (immunityActive) {
                    immEl.style.display = 'block';
                    const remaining = Math.max(0, Math.ceil((immunityEndsAt - Date.now()) / 1000));
                    document.getElementById('immunityTimer').textContent = remaining;
                } else {
                    immEl.style.display = 'none';
                }
            }

            // Check if lander passes through waypoints
            function checkWaypoints() {
                if (!waypoints || waypoints.length === 0) return;
                for (let i = 0; i < waypoints.length; i++) {
                    const wp = waypoints[i];
                    if (wp.collected) continue;
                    const dx = lander.x - wp.x;
                    const dy = lander.y - wp.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist <= wp.r) {
                        wp.collected = true;
                        collectedWaypoints += 1;
                        // Reward: restore 40% of level-starting fuel, clamp to level max
                        const fuelGain = activeConfig.fuel * 0.4;
                        lander.fuel = Math.min(activeConfig.fuel, lander.fuel + fuelGain);
                        // grant 5 seconds of asteroid immunity
                        immunityActive = true;
                        immunityEndsAt = Date.now() + 5000;
                        // show immunity immediately
                        document.getElementById('immunity').style.display = 'block';
                        document.getElementById('immunityTimer').textContent = '5';
                        // small transient notification
                        showToast('IMMUNITY', 900);
                    }
                }
            }

            // Transient toast helper (non-blocking)
            function showToast(text, duration = 900) {
                const t = document.getElementById('toast');
                t.textContent = text;
                t.style.display = 'block';
                setTimeout(() => {
                    t.style.display = 'none';
                }, duration);
            }

            // Check collision with obstacles
            function checkObstacleCollision() {
                for (let i = 0; i < obstacles.length; i++) {
                    const ob = obstacles[i];
                    const dx = lander.x - ob.x;
                    const dy = lander.y - ob.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist <= ob.r + lander.size * 0.6) {
                        // if immunity is active, ignore obstacle collisions
                        if (immunityActive) {
                            continue;
                        }
                        // immediate crash
                        gameState = "crashed";
                        lander.vx = 0;
                        lander.vy = 0;
                        lastLossReason = 'hit_obstacle';
                        showMessage("You hit an obstacle! Press SPACE to retry.", "lose");
                        return;
                    }
                }
            }

            // Return a short tip string based on how the player lost
            function getTipForLoss(reason) {
                switch (reason) {
                    case 'hit_obstacle':
                        return 'Use bullets to clear meteors before they reach you, or steer around them. Try strafing and firing early.';
                    case 'miss_waypoints':
                        return 'Waypoints restore fuel — plan a path that passes through them before landing.';
                    case 'crash':
                        return 'Reduce vertical speed and keep the angle near 0° for a safe landing; use short thrust bursts.';
                    default:
                        return '';
                }
            }

            function startObstaclesAfterDelay(ms) {
                obstaclesStarted = false;
                setTimeout(() => {
                    initObstacles();
                    obstaclesStarted = true;
                }, ms);
            }

            // Move meteors and respawn them if they exit the play area
            function updateObstacles() {
                for (let i = 0; i < obstacles.length; i++) {
                    const ob = obstacles[i];
                    ob.x += ob.vx;
                    ob.y += ob.vy;
                    // small spin can affect aesthetics if needed
                    ob.r += Math.sin((Date.now() * 0.001 + i) * (ob.spin || 0)) * 0.02;

                    // respawn if below screen or far off sides
                    if (ob.y - ob.r > CANVAS_HEIGHT + 100 || ob.x < -200 || ob.x > CANVAS_WIDTH + 200) {
                        ob.x = Math.random() * CANVAS_WIDTH;
                        ob.y = -20 - Math.random() * 300;
                        ob.vx = (Math.random() * 2 - 1) * 1.5 * (activeConfig.meteorSpeedMultiplier || 1);
                        ob.vy = (2 + Math.random() * 3) * (activeConfig.meteorSpeedMultiplier || 1);
                        ob.r = 8 + Math.random() * 18;
                    }
                }
            }

            // Draw waypoints
            function drawWaypoints() {
                for (let i = 0; i < waypoints.length; i++) {
                    const wp = waypoints[i];
                    ctx.beginPath();
                    ctx.arc(wp.x, wp.y, wp.r, 0, Math.PI * 2);
                    ctx.strokeStyle = wp.collected ? "#00ff00" : "#ffcc00";
                    ctx.lineWidth = 3;
                    ctx.stroke();

                    // inner ring
                    ctx.beginPath();
                    ctx.arc(wp.x, wp.y, wp.r * 0.6, 0, Math.PI * 2);
                    ctx.fillStyle = wp.collected ? "rgba(0,255,0,0.2)" : "rgba(255,204,0,0.08)";
                    ctx.fill();
                }
            }

            // Draw obstacles
            function drawObstacles() {
                for (let i = 0; i < obstacles.length; i++) {
                    const ob = obstacles[i];
                    // tail
                    ctx.beginPath();
                    ctx.moveTo(ob.x - ob.vx * 6, ob.y - ob.vy * 6);
                    ctx.lineTo(ob.x - ob.vx * 2, ob.y - ob.vy * 2);
                    ctx.strokeStyle = "rgba(255,150,50,0.35)";
                    ctx.lineWidth = Math.max(2, ob.r * 0.4);
                    ctx.stroke();

                    // meteor body
                    ctx.beginPath();
                    ctx.arc(ob.x, ob.y, ob.r, 0, Math.PI * 2);
                    ctx.fillStyle = "#ff9933";
                    ctx.fill();
                    ctx.strokeStyle = "#ffcc88";
                    ctx.lineWidth = 1.5;
                    ctx.stroke();
                }
            }

            // Draw everything
            function draw() {
                // Clear canvas
                ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                // Draw stars
                drawStars();

                // Draw terrain
                drawTerrain();

                // Draw waypoints (behind lander)
                drawWaypoints();

                // Draw obstacles
                drawObstacles();

                // Draw landing pad indicator
                drawLandingPad();

                // Draw lander
                drawLander();

                // Draw thrust effect
                if (lander.thrustActive && gameState === "playing") {
                    drawThrust();
                }

                // Draw bullets and shrapnel on top
                drawBullets();
                drawShrapnel();
            }

            // Draw background stars
            function drawStars() {
                ctx.fillStyle = "#fff";
                for (let i = 0; i < 100; i++) {
                    const x = (i * 123) % CANVAS_WIDTH;
                    const y = (i * 456) % (CANVAS_HEIGHT / 2);
                    const size = ((i * 789) % 3) + 1;
                    ctx.fillRect(x, y, size, size);
                }
            }

            // Draw terrain
            function drawTerrain() {
                ctx.beginPath();
                ctx.moveTo(0, CANVAS_HEIGHT);

                for (let i = 0; i < terrain.length; i++) {
                    ctx.lineTo(terrain[i].x, terrain[i].y);
                }

                ctx.lineTo(CANVAS_WIDTH, CANVAS_HEIGHT);
                ctx.closePath();

                ctx.fillStyle = "#444";
                ctx.fill();
                ctx.strokeStyle = "#666";
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            // Draw landing pad
            function drawLandingPad() {
                ctx.fillStyle = "#00ff00";
                ctx.fillRect(landingPadX, landingPadY - 5, landingPadWidth, 5);

                // Landing pad markers
                ctx.fillStyle = "#ffff00";
                ctx.fillRect(landingPadX - 5, landingPadY - 15, 10, 10);
                ctx.fillRect(
                    landingPadX + landingPadWidth - 5,
                    landingPadY - 15,
                    10,
                    10,
                );
            }

            // Draw the lander
            function drawLander() {
                ctx.save();
                ctx.translate(lander.x, lander.y);
                ctx.rotate((lander.angle * Math.PI) / 180);

                // Lander body (triangle)
                ctx.beginPath();
                ctx.moveTo(0, -lander.size);
                ctx.lineTo(-lander.size * 0.6, lander.size * 0.5);
                ctx.lineTo(lander.size * 0.6, lander.size * 0.5);
                ctx.closePath();

                ctx.fillStyle = gameState === "crashed" ? "#ff0000" : "#00ccff";
                ctx.fill();
                ctx.strokeStyle = "#fff";
                ctx.lineWidth = 2;
                ctx.stroke();

                // Landing legs
                ctx.strokeStyle = "#ccc";
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(-lander.size * 0.4, lander.size * 0.3);
                ctx.lineTo(-lander.size * 0.8, lander.size * 0.8);
                ctx.moveTo(lander.size * 0.4, lander.size * 0.3);
                ctx.lineTo(lander.size * 0.8, lander.size * 0.8);
                ctx.stroke();

                ctx.restore();
            }

            // Draw thrust effect
            function drawThrust() {
                ctx.save();
                ctx.translate(lander.x, lander.y);
                ctx.rotate((lander.angle * Math.PI) / 180);

                // Thrust flame
                const flameLength = 20 + Math.random() * 10;
                ctx.beginPath();
                ctx.moveTo(-5, lander.size * 0.5);
                ctx.lineTo(0, lander.size * 0.5 + flameLength);
                ctx.lineTo(5, lander.size * 0.5);
                ctx.closePath();

                ctx.fillStyle = "#ff6600";
                ctx.fill();

                // Inner flame
                ctx.beginPath();
                ctx.moveTo(-3, lander.size * 0.5);
                ctx.lineTo(0, lander.size * 0.5 + flameLength * 0.7);
                ctx.lineTo(3, lander.size * 0.5);
                ctx.closePath();

                ctx.fillStyle = "#ffff00";
                ctx.fill();

                ctx.restore();
            }

            // Main game loop
            function gameLoop() {
                update();
                draw();
                requestAnimationFrame(gameLoop);
            }

            // Event listeners
            document.addEventListener("keydown", (e) => {
                keys[e.code] = true;

                // If it's the very first start and instructions are visible, Space starts the game and delays asteroids
                if (firstStart && e.code === "Space") {
                    e.preventDefault();
                    // hide the instructions overlay
                    document.getElementById('instructions').style.display = 'none';
                    firstStart = false;
                    // start obstacles after 2 seconds
                    startObstaclesAfterDelay(2000);
                    return;
                }

                // If playing and Space pressed -> shoot
                if (e.code === "Space" && gameState === "playing") {
                    e.preventDefault();
                    fireBullet();
                    return;
                }

                // Space handling when not playing: next level on win, retry on crash
                if (e.code === "Space" && gameState !== "playing") {
                    e.preventDefault();
                    if (gameState === "won") {
                        // advance level if possible
                        if (currentLevel < levels.length - 1) {
                            currentLevel += 1;
                            activeConfig = levels[currentLevel];
                            showMessage(`Starting level ${currentLevel + 1}`, "");
                        } else {
                            showMessage("All levels complete! Restarting at Level 1.", "");
                            currentLevel = 0;
                            activeConfig = levels[currentLevel];
                        }
                        resetGame();
                    } else if (gameState === "crashed") {
                        // retry same level
                        activeConfig = levels[currentLevel];
                        resetGame();
                    }
                }
            });

            document.addEventListener("keyup", (e) => {
                keys[e.code] = false;
            });

            // Prevent arrow keys from scrolling the page
            document.addEventListener("keydown", (e) => {
                if (
                    [
                        "ArrowUp",
                        "ArrowDown",
                        "ArrowLeft",
                        "ArrowRight",
                        "Space",
                    ].includes(e.code)
                ) {
                    e.preventDefault();
                }
            });

            // Fire a bullet from the lander in the direction it's facing
            function fireBullet() {
                const now = Date.now();
                if (now - lastShotTime < SHOT_COOLDOWN) return; // cooldown
                lastShotTime = now;

                // check ammo
                if (ammo <= 0) {
                    // no ammo
                    return;
                }
                ammo -= 1;
                document.getElementById("ammo").textContent = ammo;

                // bullet starts at tip of lander
                const angleRad = ((lander.angle - 90) * Math.PI) / 180;
                const bx = lander.x + Math.cos(angleRad) * (lander.size + 6);
                const by = lander.y + Math.sin(angleRad) * (lander.size + 6);
                const bvx = Math.cos(angleRad) * BULLET_SPEED + lander.vx;
                const bvy = Math.sin(angleRad) * BULLET_SPEED + lander.vy;
                bullets.push({ x: bx, y: by, vx: bvx, vy: bvy, r: BULLET_RADIUS, life: 2000, born: now });
            }

            function updateBullets() {
                const now = Date.now();
                for (let i = bullets.length - 1; i >= 0; i--) {
                    const b = bullets[i];
                    b.x += b.vx;
                    b.y += b.vy;

                    // remove if out of bounds or lifetime exceeded
                    if (b.x < -50 || b.x > CANVAS_WIDTH + 50 || b.y < -50 || b.y > CANVAS_HEIGHT + 50 || now - b.born > b.life) {
                        bullets.splice(i, 1);
                    }
                }
            }

            function checkBulletCollisions() {
                // bullets vs obstacles (meteors)
                for (let bi = bullets.length - 1; bi >= 0; bi--) {
                    const b = bullets[bi];
                    for (let oi = obstacles.length - 1; oi >= 0; oi--) {
                        const ob = obstacles[oi];
                        const dx = b.x - ob.x;
                        const dy = b.y - ob.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist <= b.r + ob.r) {
                            // destroy obstacle and bullet
                            bullets.splice(bi, 1);
                            obstacles.splice(oi, 1);
                            // spawn a small explosion effect (visual only)
                            spawnShrapnel(ob.x, ob.y, ob.r);
                            break;
                        }
                    }
                }
            }

            // small visual shrapnel pieces when meteor is destroyed
            const shrapnel = [];
            function spawnShrapnel(x, y, size) {
                const count = Math.min(6, Math.max(3, Math.floor(size / 4)));
                for (let i = 0; i < count; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 1 + Math.random() * 2;
                    shrapnel.push({ x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life: 600, born: Date.now(), r: 1 + Math.random() * 2 });
                }
            }

            function updateShrapnel() {
                const now = Date.now();
                for (let i = shrapnel.length - 1; i >= 0; i--) {
                    const s = shrapnel[i];
                    s.x += s.vx;
                    s.y += s.vy;
                    s.vy += 0.02; // slight gravity for visual
                    if (now - s.born > s.life) shrapnel.splice(i, 1);
                }
            }

            function drawBullets() {
                ctx.fillStyle = "#ffff66";
                for (let i = 0; i < bullets.length; i++) {
                    const b = bullets[i];
                    ctx.beginPath();
                    ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            function drawShrapnel() {
                ctx.fillStyle = "#ffcc66";
                for (let i = 0; i < shrapnel.length; i++) {
                    const s = shrapnel[i];
                    ctx.fillRect(s.x - s.r / 2, s.y - s.r / 2, s.r, s.r);
                }
            }

            // Initialize and start game
            initTerrain();
            resetGame();
            gameLoop();
        </script>
    </body>
</html>
